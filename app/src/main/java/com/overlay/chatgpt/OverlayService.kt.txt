package com.overlay.chatgpt

import android.app.Service
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.graphics.PixelFormat
import android.os.Build
import android.os.IBinder
import android.view.*
import android.view.animation.AccelerateDecelerateInterpolator
import android.widget.FrameLayout
import android.widget.ImageView
import kotlinx.coroutines.*

class OverlayService : Service() {
    
    private lateinit var windowManager: WindowManager
    private var overlayView: FrameLayout? = null
    private var avatarView: ImageView? = null
    private lateinit var prefs: SharedPreferences
    
    private val scope = CoroutineScope(Dispatchers.Main + SupervisorJob())
    private var idleAnimationJob: Job? = null
    
    // Position modes
    enum class PositionMode {
        TOP_CORNER, SIDEBAR, AMBIENT, CUSTOM
    }
    
    private var currentMode = PositionMode.TOP_CORNER
    private var isKeyboardVisible = false
    private var isInteracting = false
    private var customX = 0
    private var customY = 0
    
    companion object {
        private const val PREFS_NAME = "overlay_prefs"
        private const val KEY_LAST_MODE = "last_mode"
        private const val KEY_CUSTOM_X = "custom_x"
        private const val KEY_CUSTOM_Y = "custom_y"
        private const val KEY_CUSTOM_WIDTH = "custom_width"
        private const val KEY_CUSTOM_HEIGHT = "custom_height"
    }
    
    override fun onCreate() {
        super.onCreate()
        windowManager = getSystemService(Context.WINDOW_SERVICE) as WindowManager
        prefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        
        // Restore previous mode and position
        restoreLastState()
        
        createOverlay()
        startIdleAnimation()
    }
    
    private fun restoreLastState() {
        val savedMode = prefs.getString(KEY_LAST_MODE, PositionMode.TOP_CORNER.name)
        currentMode = try {
            PositionMode.valueOf(savedMode ?: PositionMode.TOP_CORNER.name)
        } catch (e: Exception) {
            PositionMode.TOP_CORNER
        }
        
        // Restore custom position if in custom mode
        if (currentMode == PositionMode.CUSTOM) {
            customX = prefs.getInt(KEY_CUSTOM_X, 50)
            customY = prefs.getInt(KEY_CUSTOM_Y, 100)
        }
    }
    
    private fun saveCurrentState() {
        prefs.edit().apply {
            putString(KEY_LAST_MODE, currentMode.name)
            if (currentMode == PositionMode.CUSTOM) {
                putInt(KEY_CUSTOM_X, customX)
                putInt(KEY_CUSTOM_Y, customY)
                val params = overlayView?.layoutParams as? WindowManager.LayoutParams
                params?.let {
                    putInt(KEY_CUSTOM_WIDTH, avatarView?.width ?: 200)
                    putInt(KEY_CUSTOM_HEIGHT, avatarView?.height ?: 200)
                }
            }
            apply()
        }
    }
    
    private fun createOverlay() {
        // Create the overlay container
        overlayView = FrameLayout(this).apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.WRAP_CONTENT,
                FrameLayout.LayoutParams.WRAP_CONTENT
            )
        }
        
        // Restore custom size if available
        val savedWidth = prefs.getInt(KEY_CUSTOM_WIDTH, 200)
        val savedHeight = prefs.getInt(KEY_CUSTOM_HEIGHT, 200)
        
        // Create avatar image (you'll replace this with your actual image)
        avatarView = ImageView(this).apply {
            // Set your avatar drawable here
            setImageResource(R.drawable.avatar)
            layoutParams = FrameLayout.LayoutParams(savedWidth, savedHeight)
            scaleType = ImageView.ScaleType.CENTER_CROP
            alpha = 0.85f // Slight transparency for ambient feel
        }
        
        overlayView?.addView(avatarView)
        
        // Configure window parameters
        val params = createWindowParams()
        
        // Apply saved mode/position
        applyPositionMode(params, animate = false)
        
        // Setup touch handling for drag and resize
        setupTouchHandling(params)
        
        // Add to window manager
        try {
            windowManager.addView(overlayView, params)
            startKeyboardMonitoring()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
    
    private fun createWindowParams(): WindowManager.LayoutParams {
        val layoutType = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
        } else {
            WindowManager.LayoutParams.TYPE_PHONE
        }
        
        return WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.WRAP_CONTENT,
            layoutType,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
                    WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or
                    WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH,
            PixelFormat.TRANSLUCENT
        ).apply {
            gravity = Gravity.TOP or Gravity.START
            x = if (currentMode == PositionMode.CUSTOM) customX else 50
            y = if (currentMode == PositionMode.CUSTOM) customY else 100
        }
    }
    
    private fun startIdleAnimation() {
        idleAnimationJob?.cancel()
        idleAnimationJob = scope.launch {
            while (isActive) {
                delay(8000) // Wait 8 seconds between animations
                
                // Only animate if not interacting and keyboard isn't visible
                if (!isInteracting && !isKeyboardVisible) {
                    // Subtle breathing/blinking animation
                    avatarView?.animate()
                        ?.alpha(0.7f)
                        ?.setDuration(300)
                        ?.setInterpolator(AccelerateDecelerateInterpolator())
                        ?.withEndAction {
                            avatarView?.animate()
                                ?.alpha(0.85f)
                                ?.setDuration(300)
                                ?.setInterpolator(AccelerateDecelerateInterpolator())
                                ?.start()
                        }
                        ?.start()
                }
            }
        }
    }
    
    private fun setupTouchHandling(params: WindowManager.LayoutParams) {
        var initialX = 0
        var initialY = 0
        var initialTouchX = 0f
        var initialTouchY = 0f
        var lastTapTime = 0L
        
        overlayView?.setOnTouchListener { view, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    initialX = params.x
                    initialY = params.y
                    initialTouchX = event.rawX
                    initialTouchY = event.rawY
                    
                    // Mark as interacting to pause idle animations
                    isInteracting = true
                    
                    // Double-tap detection for mode switching
                    val currentTime = System.currentTimeMillis()
                    if (currentTime - lastTapTime < 300) {
                        cyclePositionMode(params)
                    }
                    lastTapTime = currentTime
                    true
                }
                
                MotionEvent.ACTION_MOVE -> {
                    // Allow dragging
                    params.x = initialX + (event.rawX - initialTouchX).toInt()
                    params.y = initialY + (event.rawY - initialTouchY).toInt()
                    
                    customX = params.x
                    customY = params.y
                    currentMode = PositionMode.CUSTOM
                    
                    windowManager.updateViewLayout(overlayView, params)
                    true
                }
                
                MotionEvent.ACTION_UP -> {
                    // Snap to edge if close
                    snapToEdgeIfNeeded(params)
                    
                    // Save the new position/mode
                    saveCurrentState()
                    
                    // Resume idle after a delay
                    scope.launch {
                        delay(2000)
                        isInteracting = false
                    }
                    true
                }
                
                else -> false
            }
        }
    }
    
    private fun cyclePositionMode(params: WindowManager.LayoutParams) {
        currentMode = when (currentMode) {
            PositionMode.TOP_CORNER -> PositionMode.SIDEBAR
            PositionMode.SIDEBAR -> PositionMode.AMBIENT
            PositionMode.AMBIENT -> PositionMode.TOP_CORNER
            PositionMode.CUSTOM -> PositionMode.TOP_CORNER
        }
        
        applyPositionMode(params)
        saveCurrentState()
    }
    
    private fun applyPositionMode(params: WindowManager.LayoutParams, animate: Boolean = true) {
        val displayMetrics = resources.displayMetrics
        val screenWidth = displayMetrics.widthPixels
        val screenHeight = displayMetrics.heightPixels
        
        when (currentMode) {
            PositionMode.TOP_CORNER -> {
                params.gravity = Gravity.TOP or Gravity.END
                params.x = 20
                params.y = 100
                avatarView?.layoutParams?.width = 180
                avatarView?.layoutParams?.height = 180
                avatarView?.alpha = 0.85f
            }
            
            PositionMode.SIDEBAR -> {
                params.gravity = Gravity.CENTER_VERTICAL or Gravity.END
                params.x = 10
                params.y = 0
                avatarView?.layoutParams?.width = 120
                avatarView?.layoutParams?.height = 300
                avatarView?.alpha = 0.75f
            }
            
            PositionMode.AMBIENT -> {
                params.gravity = Gravity.CENTER
                params.x = 0
                params.y = 0
                avatarView?.layoutParams?.width = screenWidth
                avatarView?.layoutParams?.height = screenHeight
                avatarView?.alpha = 0.15f // Very faint background
            }
            
            PositionMode.CUSTOM -> {
                params.gravity = Gravity.TOP or Gravity.START
                params.x = customX
                params.y = customY
                // Keep previously saved dimensions
            }
        }
        
        avatarView?.requestLayout()
        
        if (animate) {
            animateLayoutChange(params)
        } else {
            windowManager.updateViewLayout(overlayView, params)
        }
    }
    
    private fun animateLayoutChange(params: WindowManager.LayoutParams) {
        overlayView?.animate()
            ?.alpha(0.3f)
            ?.setDuration(200)
            ?.withEndAction {
                windowManager.updateViewLayout(overlayView, params)
                overlayView?.animate()
                    ?.alpha(1f)
                    ?.setDuration(300)
                    ?.start()
            }
            ?.start()
    }
    
    private fun snapToEdgeIfNeeded(params: WindowManager.LayoutParams) {
        val displayMetrics = resources.displayMetrics
        val screenWidth = displayMetrics.widthPixels
        val threshold = 50
        
        if (params.x < threshold) {
            params.x = 0
            windowManager.updateViewLayout(overlayView, params)
        } else if (params.x > screenWidth - threshold) {
            params.gravity = Gravity.TOP or Gravity.END
            params.x = 0
            windowManager.updateViewLayout(overlayView, params)
        }
    }
    
    private fun startKeyboardMonitoring() {
        // Monitor keyboard visibility by checking root view height changes
        overlayView?.viewTreeObserver?.addOnGlobalLayoutListener {
            val heightDiff = overlayView?.rootView?.height ?: 0
            val contentViewTop = overlayView?.rootView?.findViewById<View>(android.R.id.content)?.height ?: 0
            
            val wasKeyboardVisible = isKeyboardVisible
            isKeyboardVisible = heightDiff > contentViewTop * 0.15
            
            if (isKeyboardVisible != wasKeyboardVisible) {
                onKeyboardVisibilityChanged(isKeyboardVisible)
            }
        }
    }
    
    private fun onKeyboardVisibilityChanged(visible: Boolean) {
        isInteracting = visible
        
        if (visible) {
            // Fade out or slide to side when keyboard appears
            fadeOverlay(0.3f, 300)
            
            // Optionally move to top corner
            if (currentMode != PositionMode.CUSTOM) {
                scope.launch {
                    delay(100)
                    val params = overlayView?.layoutParams as? WindowManager.LayoutParams
                    params?.let {
                        it.y = 50 // Move higher
                        windowManager.updateViewLayout(overlayView, it)
                    }
                }
            }
        } else {
            // Fade back in when keyboard disappears
            fadeOverlay(0.85f, 400)
            
            // Resume idle animations after a delay
            scope.launch {
                delay(2000)
                isInteracting = false
            }
        }
    }
    
    private fun fadeOverlay(targetAlpha: Float, duration: Long) {
        avatarView?.animate()
            ?.alpha(targetAlpha)
            ?.setDuration(duration)
            ?.setInterpolator(AccelerateDecelerateInterpolator())
            ?.start()
    }
    
    // Public methods for external control
    fun setPositionMode(mode: PositionMode) {
        currentMode = mode
        val params = overlayView?.layoutParams as? WindowManager.LayoutParams
        params?.let { 
            applyPositionMode(it)
            saveCurrentState()
        }
    }
    
    fun fadeForInteraction() {
        isInteracting = true
        fadeOverlay(0.2f, 200)
    }
    
    fun restoreAfterInteraction() {
        scope.launch {
            delay(500) // Wait a bit before restoring
            fadeOverlay(0.85f, 400)
            delay(2000)
            isInteracting = false
        }
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        intent?.let {
            when (it.action) {
                "FADE" -> fadeForInteraction()
                "RESTORE" -> restoreAfterInteraction()
                "MODE_CORNER" -> setPositionMode(PositionMode.TOP_CORNER)
                "MODE_SIDEBAR" -> setPositionMode(PositionMode.SIDEBAR)
                "MODE_AMBIENT" -> setPositionMode(PositionMode.AMBIENT)
            }
        }
        return START_STICKY
    }
    
    override fun onDestroy() {
        super.onDestroy()
        idleAnimationJob?.cancel()
        scope.cancel()
        saveCurrentState() // Save state before destroying
        overlayView?.let {
            windowManager.removeView(it)
        }
    }
    
    override fun onBind(intent: Intent?): IBinder? = null
}